#java base tips

1. java中的所有函数都属于某个类的方法，所有，Java中的main必须有一个外壳类。
2. Java没有任何无符号类型。
3. Java中的char是一种表示Unicode编码的字符单元。
4. 建议不要使用char类型。
5. 在Java中不区分变量的声明与定义。
6. 关键字final表示常量。
7. const是Java的保留字，但是目前并没有使用。
8. 用static final 定义类常量，用public static final 则其它类也可使用该常量。
9. \>>是符号扩展,>>>是逻辑零扩展。
10. 用(int)Math.round(x)来对浮点数来进行摄入运算。
11. 枚举类enum Size {SMALL, MEDIUM, EXTRA_LARGE};Size s = Size.MEDIUM;
12. java中string不可变，更类似于char*,而不是char[],通常用substring(a,b)来改变string的内容。
13. string不能用==来判断相等。（在C++中则可以这么做，因为C++的string类重载了==操作。
14. 只有字符串常量是共享的，而+和substring等操作产生的结果并不是共享的。
15. 空串与null并不相同。
16. charAt(index)
17. codePointAt(index)
18. char是采用UTF-16编码，所以有的字符用char表示，需要两个代码单元。
19. 用StringBuilder 来构造字符串效率更高。
20. JAVA中若想进行格式化输出，可以采用System.out.printf(),也有String.format()
21. 文件输入输出
Scanner in = new Scanner(Paths.get("1.txt"));PrintWriter out = new PrintWriter("1.txt");
22. 不能在嵌套的块中对变量进行重定义。
23. 在循环中检测两个浮点数是否相等需要格外小心，因为0.1无法精确的用二进制表示。
24. 从javaSE7开始，case标签还可以是字符串字面值。
25. java中的break可带标签，用法类似于C中的goto。只能跳出代码块，不能跳入代码块。有待测试。
26. 大数值运算：BigInter.
27. 可以用``int[] a`` and ``int a[]``来声明数组，而初始化数组则需要：``int[] a = new int[100];
Int[] a = {1 ,2 ,3}``
初始化匿名数组new int[] {1, 2 ,3}
28. Arrays.toString(a)
29. java支持不规则数组。
30. 可以把Java的对象变量看作C++的对象指针。
31. java中的一个源文件中，只能有一个公有类，但可以有任意数目的非公有类。
32. 构造器总是伴随着new操作符来重新设置实例域的目的。
33. 在java中所有的方法都必须在类里面定义。
34. Getter and setter 的优点：
	a. 可以改变内部实现，而不不影响除了该类的方法以外的其他方法。
	b. 可以执行错误检查。
35. 如果需要返回一个可变数据域的拷贝，就应该使用clone。
36. 一个方法可以访问所属类的所有对象的私有数据。C++也有同样的特性。
37. 如果实例域被定义为final，构建对象时必须初始化这样的域。并且在之后的操作中，不能再对其进行修改，但是这并不意味着这个final对象是常量！
38. static为静态域，也可叫做类域，一个类的所有实例将共享一个static域，是可变的；可通过类名进行访问。
39. 静态方法没有隐式参数，所以其不能向对象实施操作，不能访问实例域，但是可以访问该类的静态域。
40. 每一个类可以有一个main方法--->单元测试的一种技巧。
41. 方法得到的是所有参数值得一个拷贝，所以方法不能修改传递给它的任何参数变量的内容。（对象引用的传递类比于指针的值传递）所以一个方法不能让对象参数引用一个新的对象。
42. 返回类型不是方法签名的一部分，所以不能只以返回类型的不同来重载方法。
43. 域的默认初始化：0；false；null。
44. 仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器，所以，若再提供额外的构造器后还像拥有简单的默认构造器可以：public employee(){}。
45. 可以在执行构造器之前先执行赋值操作，可以调用方法对域进行初始化。
46. 如果构造器的第一个语句形如this(…)这个构造器将调用同一个类的另一个构造器。
47. 初始化块，若果一个类中有初始化块，就会先运行初始化块，当然大多数做法是直接把这些代码放到构造器中。
48. 还可以采用static{ int a = 0;…}的形式，在类第一次加载的时候对静态域进行初始化。
49. 一个类可以使用所属包中的所有类，以及其他包中的公有类。
50. 出现命名冲突就在每个类名的前面加上完整的包名。
51. import可以导入静态方法和静态域。如：import static java.lang.System.*,就可直接out.println()。
52. 如果没没有被public 和 private 修饰，则这个部分（类，方法，变量）值可以被同一个包中的所有方法访问。
53. 默认的类路径包含了"."目录，然而如果设置了类路径，却忘记了包含"."目录，则程序任然可以通过编译，但不能运行。
54. "is-a" is the Distinctive feature of inheritance。
55. 关键词 extends 表示继承.
56. 在java中所有的继承都是公有继承。
57. 子类若想覆盖超类的方法，不能直接访问超类的私有域，只能通过关键词super调用超类的方法间接访问（在C++中则是通过采用超类名加上::操作符的形式）。因为super不是一个对象的引用，所以不能将super赋给另一个对象变量。
58. 使用super调用构造器的语句必须是子类构造器的第一条语句。
59. 如果子类的构造器没有显示地调用超类的构造器，则将自动地调用超类默认构造器。
60. 在java中，不需要把方法声明为虚拟方法，动态绑定是默认的处理方式，如果不希望让一个方法具有虚拟特征，可以把它标记为final。
61. java不支持多继承。
62. 在覆盖一个方法的时候，子类方法不能低于超类方法的可见性，比如在声明子类方法的时候遗漏了public标识符，编译器会把它解释为试图提供更严格的访问权限。
63. 阻止继承：final类和方法。不过如果将一个类声明为final，只有其中的方法自动变为final，而不包括域。16/3/8 上午11:14  161页
64. 在将超类转换为子类之前，应该使用instanof进行检查。
65. 使用``abstract`` 关键字，就不需要实现这个方法。
66. 包含一个或多个抽象方法的类本身必须被声明为抽象的。
67. 如果在子类中定义部分抽象方法或抽象方法也不定义，这样就必须将子类也标记为抽象类，另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。
68. 类即使不含抽象方法，也可以将类声明为抽象类。
69. 抽象类不能被实例化。
70. 可以定义一个抽象类的对象变量，但是它只能引用非抽象类的对象。（在C++中，只要有一个纯虚函数，这个类就是抽象类。
71. 子类也不能访问超类的私有域。
72. java中的受保护部分（protected）对所有子类及同一个包中的所有其它类都可见。
73. 如果没有明确地指出超类，Object就被认为是这个类的超类。
74. ``Objects.equal（a，b）``，如果两个参数都为``null``,则返回``true``,如果其中一个参数为``null``,则返回``false``,否则，如果连个参数都不为``null``,则调用``a.equal(b)``.
75. 如果没有定义hashCode方法，那这个类的对象的散列码是有Object类的默认hashCode导出的对象存储地址。最好使用null安全的方法Object.hashCode,如果其参数为null，这个方法会返回0，否则返回对参数调用hashCode的结果。
76. 还有更好的做法，需要组合多个散列值时，可以调用Objects.hash并提供多个参数。这个方法会对各个参数调用Objects.hashCode,并组合这些散列值。比如：
	
	``Public int hashCode(){	return Objects.hash(name, salary, hireDay);
	}``
77. 如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用ensureCapacity方法。
78. 可变参数：Public static double max(double… values)
java反射中可以使用f.setAccessible(true)来达到访问私有域的值。
79. __建议java开发者不要使用Method对象的回调功能，使用接口进行回调会使得代码的执行速度更快，更易于维护。__待验证。
80. 使用继承实现__is-a__关系，不要罔顾现实，强行继承。
81. 覆盖方法是不要改变预期的行为。
82. 使用多态，而非信息类型。
83. 不要过多的使用反射。
84. __Comparable接口__已经改进为泛型类型。
85. 接口中的所有方法自动的属于``public``，但在实现接口是必须把方法声明为'``public``,否则编译器将认为这个方法的访问属性是包可见性。
86. 接口绝不能含有实例域。
87. 可以声明接口的变量，但不能构造接口的对象；接口变量必须引用实现了接口的类对象。
88. 可以用``instanceof``检查一个对象是否实现了某个特定的接口。
89. 接口中的域将被自动设为public static final。
90. 每个类只能拥有一个超类，但却可以实现多个接口。
91. ``clone``方法是``Object``类的一个``protected``方法。 
92. 默认的克隆操作是浅拷贝，它并没有克隆包含在对象中的内部对象。
93. 对于每一个类，都需做出以下判断：
		
		a.  默认的clone方法是否满足要求。
		b.  默认的clone方法能否通过调用可变子对象的clone得到修补。
		c.  是否不应该使用clone.
	实际上，选项3是默认的。如果要选择1或2，类必须：
		
		a.  实现了``Cloneable``接口。
		b.  使用``public``访问修饰符重新定义``clone``方法。
94.  只有内部类可以是私有类。
95.  编译器修改了所有的内部类的构造器，添加一个外围类引用的参数。如果这个内部类没有定义构造器，编译器会为这个类生成一个默认的构造器。
96.  表达式``OuterClass.this``表示外围类应用，如``TalkingClock.this.beep``。
97.  在外围类的作用域之外，可以这样引用内部类：
		```OuterClass.InnerClass```
98. ```outerObject.new InnerClass(construction parameters)```
99. 编译器会把内部类翻译成用$分隔外部类名域内部类名的常规类文件，而虚拟机则对此一无所知。
100. 局部类不能用``public``或``private``访问说明符进行声明，它的作用域被限定在声明这个局部类的块中。除了它所在的那个方法之外，没有任何方法知道这个类的存在。
101. 局部类不仅可以访问包含它们的外部类，还可以访问局部变量。不过，那些局部变量必须被声明为``final``.
102. 编译器必须检测局部类对局部变量的访问，为每一个变量建立相应的数据域，并将局部变量拷贝到构造器中，以便将这些数据域初始化为局部变量的副本。
103. 匿名内部类：
		
		```new SuperType(conwtruction parameters)
		{
			inner classmethods and data
		}
		
		new interfaceType()
		{
			methods and data
		}```
104. 双括号初始化：
		
```java
invite(new ArrayList<String>() {{ add("Harry"); add("Tony");}})
```
		
		
	里边的花括号是初始化代码块。

105. ```new Object(){}.getClass().getEnclosingClass()```可以get class of static method.
106. 在内部类中不需要访问外围类对象的时候，应该使用静态内部类。可以使用嵌套类来表示静态内部类。
107. 声明在接口中的内部类自动成为static和public类。 
108. 如果出现```RuntimeException```异常，那么一定是你的问题。
109. 派生域```RuntimeException```的异常主要包含下面几种情况：

		a. 错误的类型转换。
		b. 数组访问越界。
		c. 访问空指针.
		
		


	
	
##TO BE CONTINUED
	
	
